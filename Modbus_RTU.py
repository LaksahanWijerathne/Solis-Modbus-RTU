############################################################################
############################################################################
#Communication with solis ongrid invertor v 0.00.02 ########################
# mainly target for proper communication using Modbuss RTU #################
#Author:Laksahan Wijerathna ################################################
############################################################################
############################################################################
from machine import UART, Pin
import time
from micropython import const
import upip
import uctypes
import ubinascii
#upip install 
############################################################################
uart1 = UART(1, baudrate=9600, tx=Pin(8), rx=Pin(9)) 	# Init UART1 
uart0 = UART(0, baudrate=9600, tx=Pin(0), rx=Pin(1)) 	# Init UART0
p2 = Pin(2, Pin.OUT)    								# create output pin on GPIO2
p2.off()												# PINS RE and DE connected Together and set to "LOW"
############################RS485 modbus RTU################################
############################################################################
auchCRCHi = [
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,
0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40 ]

auchCRCLo = [
0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4,
0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD,
0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7,
0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE,
0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2,
0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91,
0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88,
0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
0x40
]
############################################################################
############################################################################
def CRC16( Datalist, DataLen):
    CRCHi = 0xFF
    CRCLo = 0xFF
    uIndex = 0
    for i in range(DataLen):
        Index = CRCLo ^ Datalist[i] # pushMsg contain the massage need to be send
        #puchMsg += 1
        CRCLo = CRCHi ^ auchCRCHi[Index]
        CRCHi = auchCRCLo[Index]
        DataLen -= 1
    #print(CRCHi<<8)
    #print(CRCLo)
    
    return (CRCHi << 8 | CRCLo)
############################################################################
def writer(txData):
    #ax = ubinascii.hexlify(bytes(txData), '')
    ax = bytearray(txData,'utf-8')
    p2.on()					# set pin to "high"
    uart1.write(ax)			# other side not recive
    time.sleep(0.10)		# release littlebit        
    uart0.write(ax)			# other side not recive
    p2.off()				# set pin to "Low" 
    #print(ax)
    #print("<<<<<<<<<<<<<<<<<<<<<")

############################################################################
def modbusRTUSend(Slave,Fun,RSAH,RSAL,RCH,RCL):
    
    ##################CRC Calculation is here##############################
    #############Polinominal of Modbus RTU is :'poly': 0x8005,'init': 0xffff,'xor': 0x0000,'
    #Modbus RTU frame format - from wikipedia
    #Polynomial: x16 + x15 + x2 + 1 (CRC-16-ANSI also known as CRC-16-IBM,
    #normal hexadecimal algebraic polynomial being 8005 and reversed A001 ).
    #Initial value: 65,535.
    #######################################################################
    #The implementation of RTU reception driver may imply the management of
    #a lot of interruptions due to the t1.5 and t3.5 timers. With
    #high communication baud rates, this leads to a heavy CPU load.
    #Consequently these two timers must be strictly respected when the
    #baud rate is equal or lower than 19200 Bps. For baud rates greater
    #than 19200 Bps, fixed values for the 2 timers should be used: it is
    #recommended to use a value of 750µs for the inter-character
    #time-out (t1.5) and a value of 1.750ms for inter-frame delay (t3.5). 
    #######################################################################
    massage = [Slave,Fun,RSAH,RSAL,RCH,RCL]
    CRC=CRC16(massage, 6) # Calculate CRC value thismassage length should can be increase
    #print(CRC)
    CRCH=hex(CRC>>8)	# offset
    CRCL=hex(CRC&0xFF)	# swap
    buffer=[int(Slave),int(Fun),int(RSAH),int(RSAL),int(RCH),int(RCL),int(CRCL),int(CRCH)] # Buffer for transmit
    #######################################################################
    writer(buffer)#uart writer
    #######################################################################
    
    
####################Example testing Data###################################    
#data = [0x01,0x04, 0x0B, 0xB7, 0x00, 0x01]
#data1=[0x01 , 0x04, 0x0B, 0xBF, 0x00, 0xDE]
#01 03 0b b7 00 03
count = 5
i = 0
while count >0:
    ## This is command section That you can write your own command using this methodes
    time.sleep(5)
    #print("Start Sending: ",0x01,0x04, 0x0B, 0xBE, 0x00, 0x01)
    if i == 0:
        #######################################################################################################################
        for i in range(3):
           print("Grid OFF:")
           print(i) #0, 1, 2, 3
           ### Every massage need Replay otherwise need send again<<<<<************
           modbusRTUSend(0x01,0x05, 0x13, 0x88, 0x00, 0x00)# 5000= Grid OFF 0x0000, Cotroll to shutdown << Working
           #modbusRTUSend(0x01,0x05, 0x13, 0x88, 0xFF, 0x00)# 5000= Grid ON 0xFF00, Cotroll to Turn ON << Working
           if uart0.any() > 0:  	#///////////////////////
               #rxData = bytes()  	#////////////////////////////
               print("recived-1: ",uart0.read(32)) 	#/////////////////////////okay-uart0
               i=3
           time.sleep(5)
        ######################################################################################################################
        i=0
        for i in range(3):
           print("Power limitation switch 0xAA ON:")
           modbusRTUSend(0x01,0x04, 0x0B, 0xFE, 0x00, 0xAA)# 3070= BFE Power limitation switch 0xAA ON， 0x55 OFF (Power to 100%) (for3052 and 3081 Reg)。
           if uart0.any() > 0:  	#///////////////////////
               #rxData = bytes()  	#////////////////////////////
               print("recived-2: ",uart0.read(32)) 	#/////////////////////////okay-uart0
               i=3
           time.sleep(5)
        
        ######################################################################################################################
        i=0
        for i in range(3):
           print("Power Limitation effective:")
           modbusRTUSend(0x01,0x04, 0x0B, 0xEC, 0x00, 0xFF)# 3052 Power Limitation effective 0x64= 100=1%,  0x3E8 = 1000=10% , 0x2710 = 10,000=100%
           if uart0.any() > 0:  	#///////////////////////
               #rxData = bytes()  	#////////////////////////////
               print("recived-3: ",uart0.read(32)) 	#/////////////////////////okay-uart0
               i=3
           time.sleep(5)
        #####################################################################################################################
        i=0
        for i in range(3):
           print("Limit power Actual Value:")
           modbusRTUSend(0x01,0x04, 0x0C, 0x09, 0x00, 0xFF)# 3081= Limit power Actual Value -> 0x0A=10 (1-10W) Set to 10%
           if uart0.any() > 0:  	#///////////////////////
               #rxData = bytes()  	#////////////////////////////
               print("recived-4: ",uart0.read(32)) 	#/////////////////////////okay-uart0
               i=3
           time.sleep(5)
        #######################################################################################################################
        i=0
        for i in range(3):
           print("Grid ON:")
           print(i) #0, 1, 2, 3
           ### Every massage need Replay otherwise need send again<<<<<************
           #modbusRTUSend(0x01,0x05, 0x13, 0x88, 0x00, 0x00)# 5000= Grid OFF 0x0000, Cotroll to shutdown << Working
           modbusRTUSend(0x01,0x05, 0x13, 0x88, 0xFF, 0x00)# 5000= Grid ON 0xFF00, Cotroll to Turn ON << Working
           if uart0.any() > 0:  	#///////////////////////
               #rxData = bytes()  	#////////////////////////////
               print("recived-5: ",uart0.read(32)) 	#/////////////////////////okay-uart0
               i=3
           time.sleep(5)
           
       
    i=3
    
    if uart0.any() > 0:  	#///////////////////////
       rxData = bytes()  	#////////////////////////////
       print("recived: ",uart0.read(16)) 	#/////////////////////////okay-uart0
       count = 6
    #print(data)


    
        
